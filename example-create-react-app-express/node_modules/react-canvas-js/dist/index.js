'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * @function importAll
 * @param {any} r - Require Context.
 * @returns {string} - File paths.
 */
var importAll = function importAll(r) {
    return r.keys().map(r);
};

/**
 * @function importAllImages
 * @param {string} directory - The complete directory/folder path.
 * @param {regex} extensions - file extension filter.
 * @returns {string}
 */
var importAllImages = function importAllImages(directory) {
    var extensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\.(jpg|jpeg|png|svg)$/;

    return importAll(require.context(directory, false, extensions));
};

/**
 * @function hasProperty
 * @param {string} property - The property to check for in the given object.
 * @param {object} object - The object in which to check for above given property.
 * @returns {any}
 */
var hasProperty = function hasProperty(property, object) {
    try {
        return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object) && object.hasOwnProperty(property);
    } catch (e) {
        console.warn(e.message, e);
        return false;
    }
};

/**
 * @function isObject
 * @param {object} object - Object to check if is an object.
 * @returns {boolean}
 */
var isObject = function isObject(object) {
    try {
        return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object);
    } catch (e) {
        console.warn(e.message, e);
        return false;
    }
};

var Particle = function Particle(canvas, options) {
    classCallCheck(this, Particle);

    _initialiseProps.call(this);

    var shape = options.shape,
        color = options.color,
        image = options.image,
        size = options.size,
        precision = options.precision,
        x = options.x,
        y = options.y,
        debugOptions = options.debugOptions;


    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.shape = shape || 'circle';
    this.color = color || '#F20000';
    this.precision = precision || 2;
    this.size = this.parseSize(size) || this.parseSize(+Math.random().toFixed(this.precision));
    this.x = x || +Math.random().toFixed(this.precision);
    this.y = y || +Math.random().toFixed(this.precision);
    this.imageOptions = image || undefined;
    this.image = new Image();
    this.debug = debugOptions || { enabled: false };

    // Errors
    if (image !== undefined && !hasProperty('src', image)) {
        throw new Error("Image object must have 'src' property.");
    }

    if (!(hasProperty('width', this.size) && hasProperty('height', this.size)) && !hasProperty('radius', this.size)) {
        throw new Error("Size object must have either 'width' AND 'height' OR 'radius' property.");
    }

    if (this.debug.enabled) {
        if (hasProperty('attachAllParticles', this.debug) && this.debug.attachAllParticles) {
            window.Particles = window.Particles || [];
            window.Particles.push(this);
        }
        window.Particle = this;
    }
};

var _initialiseProps = function _initialiseProps() {
    var _this = this;

    this.parseSize = function (size) {
        var trueSize = size;
        if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {
            trueSize = _this.shape === 'circle' ? { radius: size } : { width: size, height: size };
        }
        return trueSize;
    };

    this.draw = function () {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.x;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.y;
        var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.size;

        var posX = _this.x = x;
        var posY = _this.y = y;
        var rSize = _this.size = size;

        if (_this.imageOptions) {
            _this.image.src = _this.imageOptions.src;
            _this.ctx.drawImage(_this.image, _this.x, _this.y, _this.getSize('x'), _this.getSize('y'));
        } else {
            switch (_this.shape) {
                case 'rectangle':
                case 'rect':
                case 'square':
                    var width = rSize.width,
                        height = rSize.height;

                    if (_this.shape === 'square') {
                        height = width;
                    }
                    _this.drawRectangle(posX, posY, width, height);
                    break;

                case 'circle':
                default:
                    var radius = rSize.radius;

                    _this.drawCircle(posX, posY, radius);
                    break;
            }
        }
    };

    this.drawCircle = function (x, y, radius) {
        _this.ctx.beginPath();
        _this.ctx.arc(x, y, radius, 0, Math.PI * 2);
        _this.ctx.fillStyle = _this.color;
        _this.ctx.fill();
    };

    this.drawRectangle = function (x, y, width, height) {
        _this.ctx.fillStyle = _this.color;
        _this.ctx.fillRect(x, y, width, height);
    };

    this.drawImage = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        console.log(args);
        _this.ctx.drawImage.apply(_this.ctx, args);
    };

    this.getSize = function (axis) {
        if (axis === 'x') {
            return _this.size.width || _this.size.radius;
        } else if (axis === 'y') {
            return _this.size.height || _this.size.radius;
        }
    };
};

var Particles =
/**
 * @param canvas The html canvas element
 *
 * Example Particle Options:
 * @param options = {
 *   maxParticles: 0,
 *   colors: ['red', 'green', '#ff1000'],
 *   shapes: ['square', 'circle', 'rectangle', { type: 'image', src: '/path/to/image' }],
 *   size: 0.00,
 *   minSize: 0.00,
 *   maxSize: 0.00,
 *   velocity: 0.00,
 *   minSpeed: 0.00,
 *   maxSpeed: 0.00,
 *   alpha: 0.7
 * }
 *
 */
function Particles(canvas, options) {
    classCallCheck(this, Particles);

    _initialiseProps$1.call(this);

    var maxParticles = options.maxParticles,
        backgroundColor = options.backgroundColor,
        colors = options.colors,
        shapes = options.shapes,
        size = options.size,
        minSize = options.minSize,
        maxSize = options.maxSize,
        minSpeed = options.minSpeed,
        maxSpeed = options.maxSpeed,
        alpha = options.alpha,
        frameRate = options.frameRate,
        duration = options.duration,
        precision = options.precision,
        debugOptions = options.debugOptions;


    this.particles = [];
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.precision = precision || 2;
    this.canvas.style.backgroundColor = backgroundColor || '#f1f1f1';

    this.maxParticles = maxParticles === null || maxParticles === undefined ? 50 : maxParticles;
    this.colors = Array.isArray(colors) ? colors : [colors] || ['red', 'green', 'yellow'];
    this.shapes = Array.isArray(shapes) ? shapes : [shapes] || ['circle', 'square', 'rectangle'];
    this.size = size;
    this.maxSize = +parseFloat(maxSize).toFixed(this.precision) || 20;
    this.minSize = +parseFloat(minSize).toFixed(this.precision) || 10;
    this.maxSpeed = +parseFloat(maxSpeed).toFixed(this.precision) || 0.09;
    this.minSpeed = +parseFloat(minSpeed).toFixed(this.precision) || 0.05;
    this.alpha = alpha || 0.5;
    this.frameRate = frameRate || 0;
    this.frameInterval = 1000 / this.frameRate;
    this.duration = duration || 0;
    this.debugOptions = debugOptions || { showFrameRate: false };
    this.debug = {
        frames: 0,
        start: null,
        frameRate: null
    };
    this.particleOptions = options;
    this.paused = false;
    this.createParticles();
};

var _initialiseProps$1 = function _initialiseProps() {
    var _this = this;

    this.createParticles = function () {
        var _particles = [].concat(toConsumableArray(Array(_this.maxParticles)));
        if (_this.maxParticles === 0 && _typeof(_this.shapes[0]) === 'object') {
            _particles = _this.shapes;
        }

        /**
         * @param {string|null|object} item - Shape object or string or null.
         */
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _particles.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _ref = _step.value;

                var _ref2 = slicedToArray(_ref, 2);

                var i = _ref2[0];
                var item = _ref2[1];

                var particleOptions = Object.assign(_this.particleOptions, _this.buildParticleOptions(item));
                var particle = new Particle(_this.canvas, particleOptions);
                _this.attachParticleAnimationConfig(particle, item);
                _this.positionCorrection(particle, i);

                _this.particles = !Array.isArray(_this.particles) ? [] : _this.particles;
                _this.particles.push(particle);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };

    this.buildParticleOptions = function () {
        var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var particleOptions = {};
        if (item !== null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
            particleOptions = Object.assign({}, item);
            if (hasProperty('type', item) && item.type !== 'image') {
                particleOptions.shape = item.type;
            } else if (hasProperty('type', item) && item.type === 'image') {
                particleOptions.shape = 'square';

                if (hasProperty('src', item)) {
                    particleOptions.image = {
                        src: item.src
                    };
                } else {
                    throw new Error('Shape of type `image` must have property `src`.');
                }
            } else {
                particleOptions.shape = typeof item === 'string' ? item : _this.getRandomShape();
            }
        }

        particleOptions.shape = particleOptions.shape || _this.shape || _this.getRandomShape();
        particleOptions.size = particleOptions.size || _this.size || _this.genRandomSize(particleOptions.shape);

        if (_typeof(particleOptions.size) !== 'object') {
            particleOptions.size = _this.parseSize(particleOptions.size, particleOptions);
        }

        particleOptions.color = particleOptions.color || _this.getRandomColor();
        particleOptions.x = particleOptions.x || _this.getRandomCoordinate('x', undefined, undefined, undefined, particleOptions);
        particleOptions.y = particleOptions.y || _this.getRandomCoordinate('y', undefined, undefined, undefined, particleOptions);
        return particleOptions;
    };

    this.attachParticleAnimationConfig = function (particle, item) {
        if (hasProperty('animate', particle)) {
            return particle;
        }

        particle.animate = {};
        particle.animate.bounds = {};
        if (particle.shape === 'circle') {
            particle.animate.bounds.minX = particle.getSize('x');
            particle.animate.bounds.minY = particle.getSize('y');
        } else {
            particle.animate.bounds.minX = particle.animate.bounds.minY = 0;
        }

        particle.animate.bounds.maxX = _this.canvas.width - particle.getSize('x');
        particle.animate.bounds.maxY = _this.canvas.height - particle.getSize('y');
        particle.animate.xSpace = particle.x + particle.animate.bounds.minX;
        particle.animate.ySpace = particle.y + particle.animate.bounds.minY;

        particle.animate.xSpace = _this.getDistance(particle, 'x');
        particle.animate.ySpace = _this.getDistance(particle, 'y');

        if (hasProperty('from', item)) {
            particle.animate.to = { x: particle.x, y: particle.y, size: particle.size, duration: item.to.duration };
            particle.x = item.from.x;
            particle.y = item.from.y;
            particle.size = hasProperty('size', item.from) ? item.from.size : particle.size;
        }
        if (hasProperty('to', item)) {
            particle.animate.to = item.to;
        }

        if (hasProperty('to', particle.animate)) {
            var duration = hasProperty('duration', particle.animate.to) ? particle.animate.to.duration : _this.duration;
            particle.animate.speed.x = (particle.animate.to.x - particle.x) / duration;
            particle.animate.speed.y = (particle.animate.to.y - particle.y) / duration;
            particle.animate.direction = {
                x: particle.animate.to.x - particle.x > 0 ? -1 : 1,
                y: particle.animate.to.y - particle.y > 0 ? -1 : 1
            };
        } else {
            var direction = [1, -1];
            particle.animate.speed = {};
            particle.animate.speed.x = particle.animate.speed.y = _this.getRandomFloat(_this.minSpeed, _this.maxSpeed);
            particle.animate.direction = {
                x: direction[_this.getRandomInt(0, 1)],
                y: direction[_this.getRandomInt(0, 1)]
            };
        }
    };

    this.getDistance = function (particle, axis) {
        return particle[axis] + particle.getSize(axis);
    };

    this.positionCorrection = function (particle, i) {
        var padding = 5;
        var _particles = _this.particles.splice(i);

        var _newParticles = _particles.map(function (_particle) {
            if (_particle.x < particle.animate.xSpace || _particle.animate.xSpace > particle.x) {
                var totalXSpace = particle.animate.xSpace + padding + _particle.animate.xSpace;
                if (totalXSpace < _this.canvas.width) {
                    _particle.x = particle.animate.xSpace + padding;
                } else {
                    _particle.x = particle.x - padding;
                }
            }

            if (_particle.y < particle.animate.ySpace || _particle.animate.ySpace > particle.y) {
                var totalYSpace = particle.animate.ySpace + padding + _particle.animate.ySpace;
                if (totalYSpace < _this.canvas.height) {
                    _particle.y = particle.animate.ySpace + padding;
                } else {
                    _particle.y = particle.y - padding;
                }
            }

            return _particle;
        });

        _this.particles.concat(_newParticles);
    };

    this.animate = function () {
        _this.interval = window.requestAnimationFrame(_this.animate);
        _this.draw();

        // Debug
        if (_this.debugOptions.showFrameRate) {
            _this.debug.start = _this.debug.start || performance.now();
            var now = performance.now();
            _this.debug.frames++;
            var delta = now - _this.debug.start;
            if (delta > 1000) {
                _this.debug.frameRate = _this.debug.frames;
                _this.debug.frames = 0;
                _this.debug.start = performance.now();
            }
        }
    };

    this.draw = function () {
        _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);
        _this.ctx.globalAlpha = _this.alpha;

        _this.particles.map(function (particle) {
            if (hasProperty('to', particle.animate)) {
                _this.incrementTo(particle);
            } else {
                _this.incrementor(particle);
            }

            particle.draw();
            _this.ctx.restore();

            return particle;
        });
    };

    this.clear = function () {
        window.cancelAnimationFrame(_this.interval);
    };

    this.incrementTo = function (particle) {
        // TODO: add logic
    };

    this.incrementor = function (particle) {
        var directions = ['x', 'y', 'xy'];
        var direction = directions[_this.getRandomInt(0, directions.length - 1)];

        switch (direction) {
            case 'x':
                _this.safeIncrement(particle, 'x');
                break;

            case 'y':
                _this.safeIncrement(particle, 'y');
                break;

            case 'xy':
                _this.safeIncrement(particle, 'x');
                _this.safeIncrement(particle, 'y');
                break;
        }
    };

    this.safeIncrement = function (particle, axis) {
        var projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];

        if (projection > particle.animate.bounds['max' + axis.toUpperCase()] || projection < particle.animate.bounds['min' + axis.toUpperCase()]) {
            particle.animate.direction[axis] = -1 * particle.animate.direction[axis];
            projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];
        }

        particle[axis] = projection;
    };

    this.getRandomShape = function () {
        return _this.shapes[_this.getRandomInt(0, _this.shapes.length - 1)];
    };

    this.getRandomColor = function () {
        return _this.colors[_this.getRandomInt(0, _this.colors.length - 1)];
    };

    this.getRandomCoordinate = function (axis, from, to, fixed, ctx) {
        from = from || 0;
        fixed = fixed || 2;

        if (axis === 'x') {
            // canvas width - size to keep particles within canvas boundary
            to = to || _this.canvas.width - _this.getSize('x', ctx);
        } else if (axis === 'y') {
            // canvas width - size to keep particles within canvas boundary
            to = to || _this.canvas.height - _this.getSize('y', ctx);
        } else {
            throw new Error('Illegal Axis!');
        }

        var x = _this.getRandomInt(from, to);
        return x;
    };

    this.genRandomSize = function () {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'circle';

        var size = void 0;
        if (type === 'circle') {
            size = { radius: _this.getRandomInt(_this.minSize, _this.maxSize) };
        } else {
            size = {
                width: _this.getRandomInt(_this.minSize, _this.maxSize),
                height: _this.getRandomInt(_this.minSize, _this.maxSize)
            };
            if (type === 'square') {
                size.width = size.height;
            }
        }

        return size;
    };

    this.getRandomFloat = function (min, max) {
        return Math.random() * (max - min) + min;
    };

    this.getRandomInt = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    };

    this.getSize = function (axis, particle) {
        var object = (typeof particle === 'undefined' ? 'undefined' : _typeof(particle)) === 'object' ? particle : _this;
        var dimension = axis === 'x' ? 'width' : 'height';
        if (particle.shape === 'circle') {
            dimension = 'radius';
        }
        return parseInt(object.size[dimension]);
    };

    this.parseSize = function (size, ctx) {
        var trueSize = size;
        var obj = ctx || _this;
        if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {
            trueSize = obj.shape === 'circle' ? { radius: size } : { width: size, height: size };
        }
        return trueSize;
    };
};

var aux = function aux(props) {
  return props.children;
};

var sizePropType = PropTypes.oneOf([{ width: PropTypes.number.isRequired, height: PropTypes.number }, { radius: PropTypes.number.isRequired }, PropTypes.number]);

var shapePropType = PropTypes.shape({
    type: PropTypes.oneOf(['image', 'rectangle', 'square', 'circle']).isRequired,
    src: PropTypes.string,
    size: sizePropType,
    color: PropTypes.string,
    to: PropTypes.shape({
        x: PropTypes.number,
        y: PropTypes.number,
        size: sizePropType,
        duration: PropTypes.number,
        speed: PropTypes.number
    })
});

var Canvas = function (_Component) {
    inherits(Canvas, _Component);

    function Canvas(props) {
        classCallCheck(this, Canvas);

        var _this = possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));

        _initialiseProps$2.call(_this);

        _this.handler = props.handler || Particles;
        return _this;
    }

    createClass(Canvas, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            window.addEventListener('resize', function () {
                if (_this2.canvas) {
                    _this2.canvasSizing(_this2.canvas);
                }
            });

            this.canvasSizing(this.canvas);
            if (this.particles !== null && _typeof(this.particles.debug) === 'object') {
                this.debugInterval = setInterval(function () {
                    window.test = _this2.particles.debug;
                    var debug = Object.assign({}, _this2.particles.debug);
                    _this2.setState({ debug: debug });
                }, 1000);
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _this3 = this;

            window.removeEventListener('resize', function () {
                _this3.canvasSizing(_this3.canvas);
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var debugElement = null;
            if (this.state.debug !== null && _typeof(this.state.debug) === 'object' && this.state.debug.frameRate !== null) {
                this.canvas.parentElement.style.position = 'relative';
                debugElement = React__default.createElement(
                    'div',
                    { style: {
                            position: 'absolute',
                            top: 0,
                            right: 0,
                            fontSize: '14px',
                            padding: '10px',
                            color: 'white',
                            backgroundColor: 'rgba(0,0,0,0.7)'
                        } },
                    this.state.debug.frameRate,
                    ' ',
                    React__default.createElement(
                        'i',
                        null,
                        'fps'
                    )
                );
            }

            return React__default.createElement(
                aux,
                null,
                React__default.createElement('canvas', { className: this.props.className, style: this.props.style, ref: function ref(canvas) {
                        _this4.canvas = canvas;
                    } }),
                debugElement
            );
        }
    }]);
    return Canvas;
}(React.Component);

Canvas.propTypes = {
    options: PropTypes.shape({
        maxParticles: PropTypes.number,
        color: PropTypes.string,
        colors: PropTypes.arrayOf(PropTypes.string),
        shape: PropTypes.oneOfType([shapePropType, PropTypes.string]),
        shapes: PropTypes.arrayOf(PropTypes.oneOfType([shapePropType, PropTypes.string])),
        minSize: PropTypes.number,
        maxSize: PropTypes.number,
        size: PropTypes.number,
        minSpeed: PropTypes.number,
        maxSpeed: PropTypes.number,
        alpha: PropTypes.number,
        frameRate: PropTypes.number,
        duration: PropTypes.number,
        precision: PropTypes.number,
        debugOptions: PropTypes.shape({
            enabled: PropTypes.bool.isRequired,
            attachAllParticles: PropTypes.bool,
            attachSingleParticles: PropTypes.bool
        })
    }),
    handler: function handler(props, propName, componentName) {
        if (props.handler === null || props.handler === undefined) {
            return null;
        }

        if (!props.handler.hasOwnProperty('animate') && typeof props.handler.animate !== 'function') {
            return new Error(propName + ' must have an \'animate\' method in ' + componentName + '.');
        }
        if (!props.handler.hasOwnProperty('draw') && typeof props.handler.draw !== 'function') {
            return new Error(propName + ' must have an \'draw\' method in ' + componentName + '.');
        }

        return null;
    },
    className: PropTypes.string,
    style: PropTypes.object
};

var _initialiseProps$2 = function _initialiseProps() {
    var _this5 = this;

    this.state = {
        debug: null
    };
    this.handler = null;
    this.debugInterval = null;

    this.canvasSizing = function (canvas) {
        window.can = canvas;
        var wWidth = canvas.parentElement.clientWidth;
        var wHeight = canvas.parentElement.clientHeight;

        var scale = window.devicePixelRatio;

        canvas.style.width = wWidth + 'px';
        canvas.style.height = wHeight + 'px';

        canvas.width = scale * wWidth;
        canvas.height = scale * wHeight;

        if (_this5.particles !== null && _typeof(_this5.particles) === 'object') {
            _this5.particles.clear();
            delete _this5.particles;
        }

        _this5.animate();
    };

    this.animate = function () {
        var options = _this5.props.options;
        var Handler = _this5.handler;
        _this5.particles = new Handler(_this5.canvas, options);
        _this5.particles.animate();
    };
};

exports.Canvas = Canvas;
exports.Particle = Particle;
exports.Particles = Particles;
exports.importAllImages = importAllImages;
exports.importAll = importAll;
exports.hasProperty = hasProperty;
exports.isObject = isObject;
//# sourceMappingURL=index.js.map
